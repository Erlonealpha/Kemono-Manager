import os
import sys
import argparse
import asyncio

from kemonobakend.database.models import KemonoUser
from kemonobakend.kemono.program import KemonoProgram, ProgramTools
from kemonobakend.downloader import Downloader, DownloadProperties
from kemonobakend.kemono.files import KemonoFilesFormatter
from kemonobakend.kemono.resource_handler import ResourceHandler
from kemonobakend.session_pool import SessionPool
from kemonobakend.utils import json_load
from kemonobakend.utils.progress import NormalProgress
from kemonobakend.log import logger


def add_get_user_actions(parser: argparse.ArgumentParser):
    parser.add_argument("-i", "-user_id", type=str, required=False, help="User ID of the kemono-user, need service provided")
    parser.add_argument("-s", "-service", type=str, required=False, help="Service of the kemono-user, need User ID provided")
    parser.add_argument("-si", "-service_id", type=str, required=False, help="Service ID of the discord-user")
    parser.add_argument("-u", "-url", type=str, required=False, help="Url of the kemono-user's main page, like https://kemono.su/{service}/user/{id}, do not need User ID and Service provided")

def add_urls_actions(parser: argparse.ArgumentParser):
    parser.add_argument("-u", "-urls", type=str, required=True, help="Urls of the kemono-users' main page, separated by comma, like https://kemono.su/{service}/user/{id}")

def add_formatter_actions(parser: argparse.ArgumentParser):
    '''
    formatter_name: str,
    root: str,
    folder_expr: str = None,
    file_expr: str = None,
    enable_serial: bool = True,
    serial_min_length: int = 2,
    serial_type: str = "same_folder",
    serial_start_num: int = 1,
    serial_ascending: bool = True,
    min_serial_enable_count: int = 1,
    enable_page_num: bool = True,
    page_num_min_length: int = 2,
    page_num_start: int = 1,
    page_num_include_types: list[str] = ["img", "video"],
    page_ascending: bool = True,
    min_page_enable_count: int = 1,
    allow_duplicate_file: bool = False,
    reserve_latest_duplicate_file: bool = True,
    max_single_folder_files: int = 2000,
    keep_files_continuous: bool = True,
    '''
    parser.add_argument("-config", type=str, required=False, help="Config file of the generated files, required json format.")
    parser.add_argument("-fn", "-format_name", type=str, required=False, help="Default is '{public_name}_{user_hash_id}', formatter name of the generated files")
    parser.add_argument("-root", "-root_dir", type=str, required=False, default="downloads/KemonoFiles", help="Default is 'downloads/KemonoFiles' Root directory of the generated files")
    parser.add_argument("-file_expr", type=str, required=False, help="File name expression, used to generate file name. like 'attachment.name' (python code or expression), and you also can input path_like 'path/to/file_expr.txt'")
    parser.add_argument("-folder_expr", type=str, required=False, help="Folder expression, used to generate folder path. By default, will generated folder path like 'public_name/service/file_type' (generated by python code or expression)")

    parser.add_argument("--disable_serial", action="store_true")
    parser.add_argument("-serial_min_len", type=int, default=2, help="Minimum length of serial number, default is 2")
    parser.add_argument("-serial_type", type=str, default="same_folder", choices=["same_folder", "none"], help="Type of serial number generation, default is'same_folder', 'none' means all files in same count")
    parser.add_argument("-serial_start", "-serial_start_num", type=int, default=1, help="Start serial number, default is 1")
    parser.add_argument("--serial_descending", action="store_true", help="Descending order of serial number, by default, will generate serial number in ascending order")
    parser.add_argument("-min_sec", "-min_serial_enable_count", type=int, default=2, help="Minimum count of serial number, default is 2")
    
    parser.add_argument("-disable_page_num", action="store_true", help="Disable page number, by default, will generate page number based on post id and folder")
    parser.add_argument("-page_min_len", "-page_num_min_len", type=int, default=2, help="Minimum length of page number, default is 2")
    parser.add_argument("-page_start", "-page_num_start", type=int, default=1, help="Start page number, default is 1")
    parser.add_argument("-page_it", "-page_num_include_types", type=str, default="img,video", help="Include types of page number, separated by comma, default is 'img,video'")
    parser.add_argument("--page_descending", action="store_true", help="Descending order of page number, by default, will generate page number in ascending order")
    parser.add_argument("-min_pec", "-min_page_enable_count", type=int, default=2, help="Minimum count of page number, default is 2")

    parser.add_argument("--allow_duplicate", action="store_true", help="Allow duplicate file, based on file sha256")
    parser.add_argument("--reserve_ldf", "--reserve_latest_duplicate_file", action="store_true", help="Reserve the latest duplicate file, based on published time or post id")
    parser.add_argument("-max_sff", "-max_single_folder_files", type=int, default=2000, help="Maximum number of files in a single folder, default is 2000")
    parser.add_argument("--not_kfc", "--not_keep_files_continuous", action="store_true", help = "Not keep files continuous, by default, will keep same folder and same post files in same folder, "
                                                                                                "like '...,imgs/1997_post1,imgs/1998_post1,imgs_01/0001_post2,imgs_01/0002_post2,...'")

def add_download_actions(parser: argparse.ArgumentParser):
    parser.add_argument("-filter", type=str, required=False, help="python code or expression to filter attachments, more details in examples/filter.py")
    parser.add_argument("-root", "-res_root", type=str, required=False, default="downloads/Resource", help="Root directory of the downloaded resources, path like '{sha256[:2]}/{sha256[2:4]}/{sha256}' or 'no_hash/{hashable(url)}'")
    parser.add_argument("-tmp", "-tmp_path", type=str, required=False, default="downloads/Temp", help="Root directory of the downloaded temporary files")
    parser.add_argument("--disable_strict", action="store_true", help="Strict mode, If not disabled and has sha256, file must be verified the sha256 then store to resource directory, otherwise will be removed. !Temp files will not be removed!")
    parser.add_argument("-proxies", type=str, required=False, help =  "Proxy list, separated by comma, like 'http://127.0.0.1:41001,https://127.0.0.1:41002'. "
                                                                        "Path like 'proxies.json' is also supported, this path is absolute or relative to 'data/proxies/'. Json schema see examples/proxies.json")
    parser.add_argument("-max_concurrent", type=int, required=False, default=8, help="Maximum concurrent downloads, default is 10")
    parser.add_argument("-max_concurrent_per_task", type=int, required=False, default=10, help="Maximum concurrent downloads per task, default is 4")

def get_args(*args):
    parser = argparse.ArgumentParser(description='Kemono-Manager CLI')
    sub_parser = parser.add_subparsers(dest='command')
    # add user
    add_user = sub_parser.add_parser("add-user", help="Add(update) a kemono-user and all-posts to the database")
    add_get_user_actions(add_user)
    
    # add users
    add_users = sub_parser.add_parser("add-users", help="Add(update) multiple kemono-users and all-posts to the database, only url is required")
    add_urls_actions(add_users)
    
    # KemonoFilesFormatter()
    # add formatter
    add_formatter = sub_parser.add_parser("add-formatter", aliases=["add-format"], help="Add a formatter to the database, you can use it to generate files by kemono-user's posts")
    add_formatter_actions(add_formatter)
    
    # remove formatter
    remove_formatter = sub_parser.add_parser("remove-formatter", aliases=["rm-formatter", "rm-format"], help="Remove a formatter from the database")
    remove_formatter.add_argument("-fn", "-format_name", type=str, required=True, help="Formatter name of the generated files")
    
    # generate files
    gen_files = sub_parser.add_parser("gen-files", help="Generate files by kemono-user's posts, that could be used for hardlink or backup")
    add_get_user_actions(gen_files)
    add_formatter_actions(gen_files)
    
    # generate files multi
    gen_files_multi = sub_parser.add_parser("gen-files-multi", help="Generate files by multiple kemono-users' posts. You can input config file or input formatter name that you used before.")
    add_urls_actions(gen_files_multi)
    add_formatter_actions(gen_files_multi)
    
    # download attachments
    download = sub_parser.add_parser("download", help="Download kemono-user's attachments to local directory")
    add_get_user_actions(download)
    add_download_actions(download)

    # download multi
    download_multi = sub_parser.add_parser("download-multi", help="Download multiple kemono-users' attachments to local directory.")
    add_urls_actions(download_multi)
    add_download_actions(download_multi)
    
    # hardlink files
    hardlink = sub_parser.add_parser("hardlink", help="Create hardlink of kemono-user's files to local directory, must gen-files first, you can download files first and then hardlink them")
    add_get_user_actions(hardlink)
    hardlink.add_argument("-fn", "--format_name", type=str, required=False, help="Formatter name of the generated files, Otherwise, you can input (user_id , service) / url to get default formatter name, which files generated by default formatter name")
    hardlink.add_argument("-root", "-res_root", type=str, required=False, default="downloads/Resource", help="Root directory of the downloaded resources, default is 'downloads/Resource'")
    
    # hardlink files multi
    hardlink_multi = sub_parser.add_parser("hardlink-multi", help="Create hardlink of multiple kemono-users' files to local directory. Only you can use it when formatter name is default 'public_name_{user_hash_id}'.")
    add_urls_actions(hardlink_multi)
    hardlink_multi.add_argument("-root", "-res_root", type=str, required=False, default="downloads/Resource", help="Root directory of the downloaded resources, default is 'downloads/Resource'")
    
    args = args if args else sys.argv[1:]
    return parser.parse_args(args=args)

async def add_users(urls: list[str], program: KemonoProgram):
    async def add_user(url):
        try:
            old_user = await program.get_user(url=url)
            await program.add_kemono_user(url = url)
            user = await program.get_user(url = url)
            if user is None:
                raise Exception(f"Failed to get user from {url}")
            if old_user is None:
                logger.info(f"Added user for ({user.service})\t{user.public_name}")
            elif user.updated != old_user.updated:
                logger.info(f"Updated user for ({user.service})\t{user.public_name} ({old_user.updated} => {user.updated})")
            else:
                logger.info(f"No update for ({user.service})\t{user.public_name}")
        except Exception as e:
            logger.exception(e)
    
    await ProgramTools.async_with_progress(add_user, urls, f"Adding kemono-users")

def try_load_file(path_like: str):
    try:
        if os.path.exists(path_like):
            with open(path_like, "r") as f:
                return f.read()
    except:
        return None

def get_urls(namespace):
    return namespace.u.split(",")

async def add_formatter(namespace, program: KemonoProgram):
    file_expr = namespace.file_expr
    folder_expr = namespace.folder_expr
    if file_expr is not None and (expr := try_load_file(file_expr)) is not None:
        file_expr = expr
    if folder_expr is not None and (expr := try_load_file(folder_expr)) is not None:
        folder_expr = expr
    
    formatter_p = {
        "root": namespace.root,
        "folder_expr": folder_expr,
        "file_expr": file_expr,
        "enable_serial": not namespace.disable_serial,
        "serial_min_length": namespace.serial_min_len,
        "serial_type": namespace.serial_type,
        "serial_start_num": namespace.serial_start,
        "serial_ascending": not namespace.serial_descending,
        "min_serial_enable_count": namespace.min_sec,
        "enable_page_num": not namespace.disable_page_num,
        "page_num_min_length": namespace.page_min_len,
        "page_num_start": namespace.page_start,
        "page_num_include_types": namespace.page_it.split(","),
        "page_ascending": not namespace.page_descending,
        "min_page_enable_count": namespace.min_pec,
        "allow_duplicate_file": namespace.allow_duplicate,
        "reserve_latest_duplicate_file": namespace.reserve_ldf,
        "max_single_folder_files": namespace.max_sff,
        "keep_files_continuous": not namespace.not_kfc
    }
    
    async with program.session_context() as session:
        await session.formatter_params.add_param_by_kwd(namespace.fn, **formatter_p)

def get_formatter(namespace, user: KemonoUser = None):
    file_expr = namespace.file_expr
    folder_expr = namespace.folder_expr
    if file_expr is not None and (expr := try_load_file(file_expr)) is not None:
        file_expr = expr
    if folder_expr is not None and (expr := try_load_file(folder_expr)) is not None:
        folder_expr = expr
    
    if namespace.fn is None:
        if not user:
            raise Exception("User is required to get default formatter name")
        format_name = f"{user.public_name}_{user.hash_id}"
    else:
        format_name = namespace.fn
    
    return KemonoFilesFormatter(
        formatter_name = format_name,
        root = namespace.root,
        folder_expr = folder_expr,
        file_expr = file_expr,
        enable_serial = not namespace.disable_serial,
        serial_min_length = namespace.serial_min_len,
        serial_type = namespace.serial_type,
        serial_start_num = namespace.serial_start,
        serial_ascending = not namespace.serial_descending,
        min_serial_enable_count = namespace.min_sec,
        enable_page_num = not namespace.disable_page_num,
        page_num_min_length = namespace.page_min_len,
        page_num_start = namespace.page_start,
        page_num_include_types = namespace.page_it.split(","),
        page_ascending = not namespace.page_descending,
        min_page_enable_count = namespace.min_pec,
        allow_duplicate_file = namespace.allow_duplicate,
        reserve_latest_duplicate_file = namespace.reserve_ldf,
        max_single_folder_files = namespace.max_sff,
        keep_files_continuous = not namespace.not_kfc
    )

async def get_user(namespace, program: KemonoProgram):
    return await program.get_user(namespace.i, namespace.s, namespace.si, namespace.u, )

async def get_users(urls: list[str], program: KemonoProgram):
    users = []
    for url in urls:
        user = await program.get_user(url=url)
        if user is None:
            logger.error(f"Failed to get user from {url}")
            continue
        users.append(user)
    return users

async def gen_files(user: KemonoUser, formatter: KemonoFilesFormatter, program: KemonoProgram):
    await program.add_kemono_files(formatter, user)

async def gen_files_multi(namespace, program: KemonoProgram):
    async def gen_user_files(url):
        try:
            user = await program.get_user(url=url)
            if user is None:
                raise Exception(f"Kemono user not found for {url}")
            
            if namespace.config is not None:
                formatter = KemonoFilesFormatter.from_config(namespace.config)
            else:
                if namespace.fn is not None:
                    formatter = await program.get_formatter(namespace.fn)
                else:
                    formatter = get_formatter(namespace, user)
            await program.add_kemono_files(formatter, user)
            logger.info(f"Generating files for ({user.service})\t{user.public_name}")
        except Exception as e:
            logger.exception(e)
    
    urls = get_urls(namespace)
    await ProgramTools.async_with_progress(gen_user_files, urls, f"Generating files for kemono-users")

async def download_users_attachments(users: list[KemonoUser], program: KemonoProgram, namespace):
    resource_handler = ResourceHandler(namespace.root)
    prop = DownloadProperties(
        program.session_pool,
        tmp_path=namespace.tmp,
        max_tasks_concurrent=namespace.max_concurrent,
        per_task_max_concurrent=namespace.max_concurrent_per_task,
        file_strict=not namespace.disable_strict,
    )
    downloader = Downloader(prop)
    f = try_load_file(namespace.filter)
    filter_expr = f if f is not None else namespace.filter
    await program.download_files_by_users(users, resource_handler, downloader, filter_expr=filter_expr)

async def hardlink_files(res_root: str, program: KemonoProgram, users = None, formatter_name = None):
    async def hard_link_file(t: tuple[KemonoUser, str]):
        user, formatter_name = t
        try:
            if formatter_name is None:
                # default formatter name
                formatter_name = f"{user.public_name}_{user.hash_id}"
            files = await program.get_files_by_formatter_name(formatter_name)
            if not files:
                raise Exception(f"No files found for {formatter_name}")
            if user is None:
                user_hash_id = files[0].user_hash_id
                user = await program.get_user(user_hash_id)
            
            await program.hard_link_files(res_root, files, progress=progress)
            logger.info(f"Hard linked files for {user.public_name}\t({user.service})")
        except Exception as e:
            logger.exception(e)
    
    if users is None:
        users = [(None, formatter_name)]
    else:
        users = [(user, formatter_name) for user in users]
    
    with NormalProgress() as progress:
        await ProgramTools.async_with_progress(hard_link_file, users, "Hard linking files...", progress=progress)


async def main():
    # args = ('gen-files-multi', '-urls', 'https://kemono.su/fanbox/user/2886368,https://kemono.su/fanbox/user/22220502')
    args = ()
    namespace = get_args(*args)
    main_action = namespace.command
    
    # Test
    # logger.info(namespace)
    # from sqlalchemy.ext.asyncio import create_async_engine
    # from kemonobakend.database.combine import create_all
    # engine = create_async_engine("sqlite+aiosqlite:///test/test_user.db")
    # await create_all(engine)
    
    program = KemonoProgram()
    await program.init()
    match main_action:
        case "add-user":
            id, service, url = namespace.i, namespace.s, namespace.u
            try:
                await program.add_kemono_user(id, service, url=url)
                logger.info(f"Add(update) user for ({service})\t{id}")
            except Exception as e:
                logger.exception(e)
        
        case "add-users":
            urls = get_urls(namespace)
            await add_users(urls, program)
        
        case "add-formatter":
            if namespace.fn is None:
                raise Exception("Formatter name is required")
            try:
                await add_formatter(namespace, program)
            except Exception as e:
                logger.exception(e)
            logger.info(f"Add formatter {namespace.fn}")
        
        case "gen-files":
            try:
                user = await get_user(namespace, program)
                if user is None:
                    logger.error(f"Failed to get user from {namespace.i}, {namespace.s}, {namespace.si}, {namespace.u}")
                    return
                formatter = get_formatter(namespace, user)
                await gen_files(user, formatter, program)
            except Exception as e:
                logger.exception(e)
            logger.info(f"Generating files for ({user.service})\t{user.public_name}")
        
        case "gen-files-multi":
            await gen_files_multi(namespace, program)
        
        case "download":
            user = await get_user(namespace, program)
            await download_users_attachments([user], program, namespace)
        
        case "download-multi":
            urls = get_urls(namespace)
            users = await get_users(urls, program)
            await download_users_attachments(users, program, namespace)
        
        case "hardlink":
            formatter_name = namespace.fn
            if formatter_name is None:
                user = await get_user(namespace, program)
            else:
                user = None
            await hardlink_files(namespace.root, program, users=[user], formatter_name=formatter_name)
        
        case "hardlink-multi":
            urls = get_urls(namespace)
            users = await get_users(urls, program)
            await hardlink_files(namespace.root, program, users=users)
        
        case _:
            logger.error(f"Unknown action: {main_action}")
            return

if sys.platform == "win32":
    policy = asyncio.WindowsSelectorEventLoopPolicy()
    asyncio.set_event_loop_policy(policy)

asyncio.run(main())